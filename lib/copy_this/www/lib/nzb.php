<?php
require_once(WWW_DIR . "/lib/framework/db.php");
require_once(WWW_DIR . "/lib/site.php");
require_once(WWW_DIR . "/lib/category.php");
require_once(WWW_DIR . "../misc/update_scripts/nix_scripts/tmux/lib/Enzebe.php");

/**
 * This class manages creation, storage and retrieval of NZB files.
 */
class NZB
{
	/**
	 * Default constructor.
	 *
	 * @param \DB $pdo
	 *
	 * @access public
	 */
	public function __construct(&$pdo = null)
	{
		$this->pdo = ($pdo instanceof \DB ? $pdo : new \DB());
		$s = new Sites();
		$this->site = $s->get();

		$this->tablePerGroup = ($this->site->tablepergroup == 0 ? false : true);
		$nzbSplitLevel = $this->site->nzbsplitlevel;
		$this->nzbSplitLevel = (empty($nzbSplitLevel) ? 1 : $nzbSplitLevel);
		$this->siteNzbPath = (string)$this->site->nzbpath;
		if (substr($this->siteNzbPath, -1) !== DS) {
			$this->siteNzbPath .= DS;
		}
	}

	/**
	 * Writes out the nzb when processing releases. Performed outside of smarty due to memory issues
	 * of holding all parts in an array.
	 */
	function writeNZBforReleaseId($relid, $name, $catId, $path, $groupID)
	{
		$db = new DB();
		$cat = new Category();
		$this->groupID = $groupID;
		// Set table names
		if ($this->tablePerGroup === true) {
			if ($this->groupID == '') {
				exit("$this->groupID is missing\n");
			}
			$bName = 'binaries_' . $this->groupID;
			$pName = 'parts_' . $this->groupID;
		} else {
			$bName = 'binaries';
			$pName = 'parts';
		}
		$catrow = $cat->getById($catId);
		$site = new Sites();

		$fp = gzopen($path, "w");
		if ($fp) {
			gzwrite($fp, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
			gzwrite($fp, "<!DOCTYPE nzb PUBLIC \"-//newzBin//DTD NZB 1.1//EN\" \"http://www.newzbin.com/DTD/nzb/nzb-1.1.dtd\">\n");
			gzwrite($fp, "<nzb xmlns=\"http://www.newzbin.com/DTD/2003/nzb\">\n\n");
			gzwrite($fp, "<head>\n");
			if ($catrow)
				gzwrite($fp, " <meta type=\"category\">" . htmlspecialchars($catrow["title"], ENT_QUOTES, 'utf-8') . "</meta>\n");
			if ($name != "")
				gzwrite($fp, " <meta type=\"name\">" . htmlspecialchars($name, ENT_QUOTES, 'utf-8') . "</meta>\n");
			gzwrite($fp, "</head>\n\n");

			$result = $db->queryDirect(sprintf("SELECT %s.*, UNIX_TIMESTAMP(date) AS unixdate, groups.name as groupname FROM %s inner join groups on %s.groupID = groups.ID WHERE %s.releaseID = %d ORDER BY %s.name",
					$bName,
					$bName,
					$bName,
					$bName,
					$relid,
					$bName));
			while ($binrow = $db->getAssocArray($result)) {
				$groups = array();
				$groupsRaw = explode(' ', $binrow['xref']);
				foreach ($groupsRaw as $grp)
					if (preg_match('/^([a-z0-9\.\-_]+):(\d+)?$/i', $grp, $match) && strtolower($grp) !== 'xref')
						$groups[] = $match[1];

				if (count($groups) == 0)
					$groups[] = $binrow["groupname"];

				gzwrite($fp, "<file poster=\"" . htmlspecialchars($binrow["fromname"], ENT_QUOTES, 'utf-8') . "\" date=\"" . $binrow["unixdate"] . "\" subject=\"" . htmlspecialchars($binrow["name"], ENT_QUOTES, 'utf-8') . " (1/" . $binrow["totalParts"] . ")\">\n");
				gzwrite($fp, " <groups>\n");
				foreach ($groups as $group)
					gzwrite($fp, "  <group>" . $group . "</group>\n");
				gzwrite($fp, " </groups>\n");
				gzwrite($fp, " <segments>\n");

				$resparts = $db->queryDirect(sprintf("SELECT DISTINCT(messageID), size, partnumber FROM %s WHERE binaryID = %d ORDER BY partnumber",
						$pName,
						$binrow["ID"]));
				while ($partsrow = $db->getAssocArray($resparts)) {
					gzwrite($fp, "  <segment bytes=\"" . $partsrow["size"] . "\" number=\"" . $partsrow["partnumber"] . "\">" . htmlspecialchars($partsrow["messageID"], ENT_QUOTES, 'utf-8') . "</segment>\n");
				}
				gzwrite($fp, " </segments>\n</file>\n");
			}
			gzwrite($fp, "<!-- generated by newznab " . $site->version() . " -->\n</nzb>");
			gzclose($fp);

			if (is_file($path)) {
				$db->queryExec(
					sprintf('
						UPDATE releases SET nzbstatus = %d WHERE ID = %d',
						Enzebe::NZB_ADDED,
						$relid
					)
				);

				// Chmod to fix issues some users have with file permissions.
				chmod($path, 0777);

				return true;
			} else {
				echo "ERROR: $path does not exist.\n";
			}
		}
	}

	/**
	 * Builds a full path to the nzb file on disk. nzbs are stored in a subdir of their first char.
	 */
	function getNZBPath($releaseGuid, $sitenzbpath = "", $createIfDoesntExist = false)
	{
		if ($sitenzbpath == "") {
			$s = new Sites;
			$site = $s->get();
			$sitenzbpath = $site->nzbpath;
		}

		$nzbpath = $sitenzbpath . substr($releaseGuid, 0, 1) . "/";

		if ($createIfDoesntExist && !file_exists($nzbpath))
			mkdir($nzbpath);

		return $nzbpath . $releaseGuid . ".nzb.gz";
	}

	/**
	 * Returns a simple file listing from the parts inside the NZB.
	 */
	function nzbFileList($nzb)
	{
		$result = array();

		$xml = @simplexml_load_string(str_replace("\x0F", '', $nzb));
		$num_pars = 0;
		if (!$xml || strtolower($xml->getName()) != 'nzb')
			return false;

		$i = 0;
		foreach ($xml->file as $file) {
			//subject
			$title = $file->attributes()->subject;
			if (preg_match('/\.par2/i', $title))
				$num_pars++;

			$result[$i]['title'] = "$title";

			if (preg_match('/\.(7z|ai7|srr|srt|sub|aiff|asc|avi|audio|bin|bz2|c|cfc|cfm|chm|class|conf|cpp|cs|css|csv|deb|divx|doc|dot|eml|enc|file|gif|gz|hlp|htm|html|image|iso|jar|java|jpeg|jpg|js|lua|m|mm|mov|mp3|mpg|odc|odf|odg|odi|odp|ods|odt|ogg|pdf|pgp|php|pl|png|ppt|ps|py|ram|rar|rb|rm|rpm|rtf|sig|sql|swf|sxc|sxd|sxi|sxw|tar|tex|tgz|txt|vcf|video|vsd|wav|wma|wmv|xls|xml|xpi|xvid|zip7|rar|par2|mp3|exe|zip|ace|nzb|r\d{2,3}|jpg|txt|nfo|sfv|cue|m3u)[" ]/i', $file->attributes()->subject, $ext)) {
				if (preg_match('/\.(r\d{2,3})/i', $ext[0], $extrar))
					$ext[1] = "rar";

				$result[$i]['ext'] = strtolower($ext[1]);
			} else {
				$result[$i]['ext'] = "";
			}

			//filesize
			$filesize = $numsegs = 0;
			foreach ($file->segments->segment as $segment) {
				$filesize += $segment->attributes()->bytes;
				$numsegs++;
			}
			$result[$i]['size'] = $filesize;

			//file completion
			preg_match('/\((\d+)\/(?P<total>\d+)\)$/', $title, $parts);
			$result[$i]['partstotal'] = (isset($parts['total']) ? $parts['total'] : 0);
			$result[$i]['partsactual'] = $numsegs;

			$i++;
		}

		return $result;
	}
}